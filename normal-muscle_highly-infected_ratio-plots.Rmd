---
title: "Normal Muscle vs Highly Infected Tissue Selected Ratios"
author: "<span style='font-size: 17px;'>`r Sys.info()[['user']]`</span><br><span style='font-size: 12px; color:#696969;'>Eberlin Lab, Department of Surgery<br>Baylor College of Medicine</span>"
date: "<span style='font-size: 15px; color: black;'>`r format(Sys.time(), '%B %d, %Y %H:%M')`</span>"
knit: (function(inputFile, encoding) { 
      proj_name <- tools::file_path_sans_ext(basename(inputFile));
      out_dir <- paste0(Sys.Date(), "_", proj_name);
      if(!file.exists(out_dir)) {   dir.create(out_dir) };
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), 
                        out_dir, 
                        paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"),"_", proj_name, ".html"))) 
                        })
output: 
  html_document:
    keep_md: yes
    toc: false
geometry: margin=0.5in
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style type="text/css">
.main-container {
max-width: 1600px;
margin-left: auto;
margin-right: auto;
}
</style>
```

```{css, echo=FALSE}
h1,h2, h3, h4, h5, p {
text-align: center;
font-size: 20px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE, cache = TRUE)
## cache set to TRUE because sometimes otherwise the files directory disappears for some users
```

```{r libraries, message = FALSE, warning = FALSE}
library(rmarkdown)
library(knitr)
library(kableExtra)
library(ggpubr)

library(tidyverse)
library(reshape2)
library(readxl)
library(rawrr)
library(sqldf)
library(readxl)

library(stringr)
library(doParallel)
library(fcluster)
library(johnfuncs)
```

```{r user input}
## Full path to folder with sample files (excel or csv, or raw Thermo files)
sample_dir <- gsub("\\\\", "/", r"(C:\Users\Jacob\OneDrive - Baylor College of Medicine\Documents\Manoj\Microbial-Project\Data\Normal muscle vs Highly Infected)")

## Full path to feature list, otherwise NA
feature_file <- gsub("\\\\", "/", r"(C:\Users\Jacob\Box\Eberlin_Lab_BCM\People\MANOJ\Renamed_Gram_positive_Gram_negative_Isolates_May2025\molecular Identity with Chemical  Formula\Master Feature List July_2025.xlsx)")

## Full path to background peak list, otherwise NA
background_file <- NA

## ---------------------------------------------------------------------------

## Scan numbers to import when using raw Thermo files
scans <- 1
#scans <- 50:500 ## number of scans to extract from each raw file

## Mass range to filter
mass_range <- c(100,1000)

## Peak Alignment Method: "clustering", "binning", or "featurelist"
peak_alignment_method <- "clustering"

## If peak alignment method is "clustering":
clust_h <- 0.05 ## Height at which to cut dendrogram to determine clusters

## If peak alignment method is "featurelist":
ppm_error <- 5 ## Mass error tolerance of sample peaks to match to feature peaks

## Normalization Method: "tic", "maxpeak", "median", "medianlog", or "none"
normalization_method <- "tic" 

## Select ratio peaks
## These values come from the gram classification Lasso ratio features
## From "Microbial-Project\outputs\ratio-lasso_gram_featurelist_2025-06-23\2025-06-23_16.12_ratio-lasso_gram_featurelist.html"
ratio_input <- gsub("\\\\", "/", r"(C:\Users\Jacob\OneDrive - Baylor College of Medicine\Documents\Manoj\Microbial-Project\Some expected mz ratio _5aug2025.xlsx)")
ratio_input <- read_xlsx(ratio_input, sheet = "Sheet1") # Ratios picked by Manoj
#ratio_input <- read_xlsx(ratio_input, sheet = "Sheet2") # Ratios selected as gram lasso features

num_mz <- ratio_input$mz1
den_mz <- ratio_input$mz2
```

```{r create output directory, include = FALSE}
proj_name <- tools::file_path_sans_ext(basename(rstudioapi::getSourceEditorContext()$path))

out_dir <- file.path("outputs", paste0(proj_name, "_", Sys.Date()))

if(!file.exists(out_dir)) {   
  dir.create(out_dir, recursive = TRUE) 
  }

files_dir <- file.path(out_dir, paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"), "_", proj_name, "_files"))

if(!file.exists(files_dir)) {   
  dir.create(files_dir, recursive = TRUE) 
  }
```

```{r other settings}
## Signal-to-Noise Ratio Threshold
SNR_thresh <-  2

## Peak filter
p <- 0.10 ## A peak present in fewer than p*100% of samples is removed, default = 0.10 or 10%

## Randomization seed
seed <- 1234
```

```{r classes}
## read sub-directories for class names
classes <- gsub(file.path(sample_dir, "/"), "", list.dirs(sample_dir, recursive=FALSE), fixed=TRUE)
```

```{r file extension}
## Looking at all files since there is an extra directory level between classes and the files themselves
all_files <- list.files(sample_dir, recursive = TRUE, full.names = TRUE)
exts <- unique(tools::file_ext(all_files))

if (length(exts) == 0) {
  stop("No files found under sample_dir!")
} else if (length(exts) > 1) {
  warning("Multiple extensions detected: ", paste(exts, collapse = ", "))
}

sample_file_ext <- exts[1]
```

```{r file names}
## Added in extra level so that we keep species or skeletal/muscle information for possible future analysis
file_name_list <- lapply(classes, function(cl) {
  # find every species folder under class “cl”
  species_dirs <- list.dirs(
    path       = file.path(sample_dir, cl), 
    recursive  = FALSE, 
    full.names = TRUE
  )
  
  # list files in each species folder, matching .<ext> at the end
  files_per_species <- lapply(species_dirs, function(sp) {
    list.files(
      path       = sp,
      pattern    = paste0("\\.", sample_file_ext, "$"),  # regex for “.ext” at end
      full.names = TRUE
    )
  })
  
  # flatten into one vector and return
  unlist(files_per_species, use.names = FALSE)
})

# ensure consistent ordering
file_name_list <- lapply(file_name_list, sort)
```

```{r sample names}
sample_names_list <- lapply(file_name_list, function(x) tools::file_path_sans_ext(basename(x)))
names(sample_names_list) <- classes

sample_names <- unlist(sample_names_list)

sample_names_df <- purrr::map_df(sample_names_list, ~as.data.frame(.x), .id="id")
colnames(sample_names_df) <- c("class", "sample_name")
```

```{r species list}
species_list <- lapply(file_name_list, function(paths) {
  basename(dirname(paths))
})
species_list <- unlist(species_list, use.names = FALSE)
```

```{r csv data}
if (sample_file_ext == "csv") {
  fixed_objects <- list(mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_csv(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r excel data}
if (sample_file_ext == "xlsx") {
  fixed_objects <- list(mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_xlsx(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r raw Thermo data}
## If sample files are raw Thermo
if (sample_file_ext == "raw") {
  fixed_objects <- list(scans = scans, mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_raw_thermo(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r peak alignment clustering}
## If peak alignment method is clustering
if (peak_alignment_method == "clustering") {
  
  clust_int_method  <-  "sumints" ## Handling of multiple intensities aggregating to one cluster centroid: "sumints" or "maxint"
  
  all_mz <- spectra_list %>%
    flatten() %>%
    map(~ round(.x$m.z, 3)) %>%
    unlist() %>%
    sort()
  
  ## Cluster peaks into centroids
  tree <- fcluster(all_mz)
  clust_mz <- fcutree(all_mz, tree, h=clust_h)
  clustMZ <- sort(clust_mz$centroid)
  
  ## Match cluster centroids to sample peaks
  clusterMatrixList <- lapply(spectra_list, function(x, y, z, w) 
    get_cluster_matrix(x, y, z, w), y=clustMZ, z = clust_h, w = clust_int_method)
  
  preprocList <- lapply(clusterMatrixList, function(x) as.matrix(get_data_matrix_clustering(x)))
  
  aligned_spectra <- do.call(rbind, preprocList)
  
  colnames(aligned_spectra) <- clustMZ
  rownames(aligned_spectra) <- sample_names
  
  ## FILTER #3: REMOVE RARE/UNCOMMON PEAKS PRESENT < 10% SAMPLES
  mz_count_filter <- colSums(aligned_spectra != 0) > as.integer(nrow(aligned_spectra)*p)
  aligned_spectra <- aligned_spectra[, mz_count_filter]
  
  filtered_mz <- clustMZ[mz_count_filter]
  
  centroid_min_max <- identify_clusters(clust_mz, all_mz, filtered_mz)
  
  ## FILTER #4: REMOVE BACKGROUND PEAKS (IF BACKGROUND FILE PRESENT)
  if (!is.na(background_file)) {
    ## Read background file, check if it has a header
    if(is.character(read.csv(background_file, header = FALSE, nrows = 1)[1,1]) == TRUE) {
      bg_mz <- read.csv(background_file, header = TRUE)
    } else {
      bg_mz <- read.csv(background_file, header = FALSE)
    }
    
    colnames(bg_mz) <- "mz"
    
    # match bg_mz to cluster centroid
    bg_centroids <- sqldf("SELECT centroid_min_max.centroid, bg_mz.*
          FROM bg_mz,centroid_min_max
          WHERE bg_mz.mz BETWEEN centroid_min_max.min_mz AND centroid_min_max.max_mz")
    
    ## Remove peaks from aligned_spectra that are in bg_mz_centroid
    bg_ind <- which(filtered_mz %in% unique(bg_centroids$centroid))
    
    filtered_mz <- filtered_mz[-c(bg_ind)]
    aligned_spectra <- aligned_spectra[, -c(bg_ind)]
  }
}
```

```{r peak alignment binning}
if (peak_alignment_method == "binning") {
  ## Hard coded that m/z values are rounded to 2 decimal places and intensities of peaks that fall into the same bin are summed (by John Lin). 
  ## TBD about changing this - FEJ 2024-09-06
  
  all_mz <- spectra_list %>%
    flatten() %>%
    map(~ round(.x$m.z, 2)) %>% ## round to 2 decimal places
    unlist() %>%
    sort() 
  
  ## FILTER #3: REMOVE RARE/UNCOMMON PEAKS PRESENT < 10% SAMPLES
  mz_count <- table(all_mz)
  mz_count_filter <- mz_count > as.integer(length(sample_names)*p)
  filtered_mz <- as.numeric(names(mz_count)[mz_count_filter])
  
  ## Bin sample peaks
  preprocList <- lapply(spectra_list, function(x,z) get_data_matrix_binning(x,z), z=filtered_mz)
  
  aligned_spectra <- do.call(rbind, preprocList)
  
  colnames(aligned_spectra) <- filtered_mz
  rownames(aligned_spectra) <- sample_names
  
  ## FILTER #4: REMOVE BACKGROUND PEAKS (IF BACKGROUND FILE PRESENT)
  if (!is.na(background_file)) {
    ## Read background file, check if it has a header
    if(is.character(read.csv(background_file, header = FALSE, nrows = 1)[1,1]) == TRUE) {
      bg_mz <- round(read.csv(background_file, header = TRUE),2)
    } else {
      bg_mz <- round(read.csv(background_file, header = FALSE), 2)
    } ## round to 2 decimal places for binned values
    
    aligned_spectra <- aligned_spectra[, !(colnames(aligned_spectra) %in% bg_mz)]
    filtered_mz <- as.numeric(colnames(aligned_spectra))
  }
  
  centroid_min_max <- NA
}
```

```{r peak alignment feature list}
if (peak_alignment_method == "featurelist") {
  background_file <- NA
  
  ## Read file with feature peaks
  feature_df <- read_xlsx(feature_file)
  feature_peaks <- unlist(feature_df[,2])
  
  
  ## Feature mz plus/minus instrument mass error, round to 3 decimal places
  mass_error <- (ppm_error * feature_peaks)/1e6
  
  feature_peaks <- data.frame(feature_mz = feature_peaks,
                              mass_error = mass_error,
                              mass_error_lower = round(feature_peaks - mass_error,3),
                              mass_error_upper = round(feature_peaks + mass_error,3))
  
  ## fixed objects for exporting to parallel computing
  fixed_objects <- list(feature_peaks = feature_peaks)
  
  feature_matched_spectra <- nested_feature_peak_alignment(spectra_list, fixed_objects)
  
  ## turn list of lists into dataframe
  feature_matched_spectra <- lapply(feature_matched_spectra, function(x) x %>%
                                      reduce(full_join,by = "feature_mz")) %>% 
    reduce(full_join,by = "feature_mz")
  
  ## sort by target_mz
  feature_matched_spectra <- feature_matched_spectra[order(feature_matched_spectra$feature_mz), ]
  
  filtered_mz <- feature_matched_spectra$feature_mz
  
  ## feature_mass column to rownames
  feature_matched_spectra <- feature_matched_spectra %>% 
    remove_rownames %>% 
    column_to_rownames(var = "feature_mz") %>% 
    as.data.frame()
  
  ## Add sample names as column names
  colnames(feature_matched_spectra) <- sample_names
  
  ## Replace NA with 0
  feature_matched_spectra <- replace(feature_matched_spectra, is.na(feature_matched_spectra), 0)
  
  ## Transpose so rows are samples and columns are masses
  aligned_spectra <- t(feature_matched_spectra)
  
  ## remove columns that are only zeros
  zero_col <- which(colSums(aligned_spectra==0) == nrow(aligned_spectra))
  if (length(zero_col) != 0) {
    filtered_mz <- filtered_mz[-c(zero_col)]
    aligned_spectra <- aligned_spectra[, -c(zero_col)]
  }
  
  centroid_min_max <- NA
}
```

```{r normalization}
xall <- normalize_pixel(aligned_spectra, normalization_method)
```

```{r yall}
## create yall object 
yall <- foreach(i = 1:length(file_name_list), .combine = c) %do% {
  rep(i, length(file_name_list[[i]])) }

## factorize yall
yall <- factor(yall,levels=c("1","2"),labels = classes)
species <- foreach(i = 1:length(file_name_list), .combine = c) %do% {
  rep(i, length(file_name_list[[i]])) }
```

``` {r select peaks of interest}
## Match peaks in xall to target peaks
col_mzs <- as.numeric(colnames(xall))
num_idx <- sapply(num_mz, function(m) which.min(abs(col_mzs - m)))
den_idx <- sapply(den_mz, function(m) which.min(abs(col_mzs - m)))
```

``` {r ratios}
## Build numerator and denominator matrices
numerator <- xall[, num_idx]
denominator <- xall[, den_idx]

## Manually check pairs
head(
  data.frame(
    sample = rownames(xall)[1:5],
    num    = numerator[1:5, 1],
    den    = denominator[1:5, 1],
    ratio  = log(numerator[1:5, 1] / denominator[1:5, 1])
  )
)

## Calculate ratios
ratio_df <- purrr::map_dfr(seq_len(ncol(numerator)), function(i) {
  tibble(
    class = yall,
    ratio = ifelse(
      (numerator[, i] != 0 & denominator[, i] != 0), ## Only calculates if both peaks are present
      log(numerator[, i] / denominator[, i]), 
      NA_real_),
    ratio_label = paste0("m/z ", num_mz[i], " / m/z ", den_mz[i]),
    sample = rownames(xall),
    species = species_list
  )
})

## Make sure class is a factor
ratio_df <- ratio_df |>
  mutate(class = factor(class, levels = sort(unique(class))))

## Split into one df per ratio
ratio_list <- split(ratio_df, ratio_df$ratio_label)
ratio_list <- ratio_list[c("m/z 748.528 / m/z 749.532","m/z 747.518 / m/z 748.528")]
```

``` {r plots}
## Plot each ratio separately and save
## Infinities are capped to just outside the min/max values and labelled accordingly
## Plot each ratio separately and save
library(scales)
library(ggpubr)
library(viridis)
library(ggnewscale)
library(purrr)
library(dplyr)
library(ggplot2)

imap(ratio_list, function(df, ratio_nm) {
  
  ## Filter out non-finite ratios
  df2 <- df %>%
    filter(is.finite(ratio)) # Removes NA (Including Inf and -Inf from above ratio_df code)

  ## Split by class
  muscle_df  <- df2 %>% filter(class == "Uninfected Muscle")
  species_df <- df2 %>% filter(class != "Uninfected Muscle")

  ## Define colors
  muscle_names <- sort(unique(muscle_df$species))
  species_names <- sort(unique(species_df$species))

  muscle_cols  <- c("red", "blue")[seq_along(muscle_names)]
  species_cols <- viridisLite::viridis(length(species_names), option = "H")

  ## Define y-axis breaks
  fin <- df2$ratio
  fin_breaks <- pretty(fin, 5)

  ## Base plot
  p <- ggplot(df2, aes(x = class, y = ratio)) +
    
    ## Neutral boxplots
    geom_boxplot(
      width = 0.4, outlier.shape = NA, alpha = 0.2,
      color = "black", fill = "gray90"
    ) +

    ## Muscle points
    geom_jitter(
      data = muscle_df,
      aes(fill = species),
      color = "black",
      shape = 21,               # filled circles
      width = 0.15, size = 2, alpha = 0.9,
      show.legend = TRUE
    ) +
    scale_fill_manual(
      name = "Muscle Type",
      values = setNames(muscle_cols, muscle_names),
      guide = guide_legend(override.aes = list(shape = 21, size = 3, fill = muscle_cols),
                           order = 2)
    ) +

    ## Reset color scale for species legend
    ggnewscale::new_scale_color() +

    ## Species points
    geom_jitter(
      data = species_df,
      aes(color = species),
      shape = 16,               # same as muscle points visually
      width = 0.15, size = 2, alpha = 0.9,
      show.legend = TRUE
    ) +
    scale_color_manual(
      name = "Infected Species",
      values = setNames(species_cols, species_names),
      guide = guide_legend(override.aes = list(size = 3),
                           order = 1)
    ) +

    ## Wilcoxon Test
    {
      if (n_distinct(df2$class) == 2) {
        stat_compare_means(
          data = df2,
          method = "wilcox.test",
          comparisons = list(c("Uninfected Muscle", "Highly Infected Tissue")),
          label = "p.format",
          label.x = 1.5,
          label.y = max(df2$ratio, na.rm = TRUE) * 1.02,
          size = 5
        )
      } else NULL
    } +

    ## Axis & Theme
    scale_y_continuous(
      breaks = fin_breaks,
      expand = expansion(mult = c(0.05, 0.1))
    ) +
    labs(
      title = ratio_nm,
      x = "Tissue Type",
      y = "log(Finite TIC Normalized Intensity Ratio)"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      axis.text.x   = element_text(size = 11),
      plot.title.position = "plot",
      plot.title    = element_text(hjust = 0.5, margin = margin(b = 10)),
      plot.margin = margin(t = 20, r = 20, b = 20, l = 20),
      legend.position = "right",
      legend.box = "vertical"
    )

  ## Save
  safe_nm <- paste0("ratio_", gsub("[^0-9A-Za-z]+", "_", ratio_nm), ".png")
  ggsave(
    filename = file.path(files_dir, safe_nm),
    plot     = p,
    width    = 9, height = 12,
    dpi      = 300, bg = "white"
  )

  invisible(NULL)
})
```

<br>

#### **Preprocessing and Statistical Model Settings**

```{r chunk3, fig.align = "center"}
if (peak_alignment_method == "clustering") {
  cluster_bin_size <- c("Cluster Height:", clust_h)
} else if (peak_alignment_method == "binning") {
  cluster_bin_size <- c("Bin Size:", "0.01")
} else if (peak_alignment_method == "featurelist") {
  cluster_bin_size <- c("Peak Mass Error:", paste0(ppm_error, " ppm"))
}

if (is.null(background_file)) {
  bg_exclusion <- "no"
} else if (!is.null(background_file)) {
  bg_exclusion <- "yes"
}

settings_df <- rbind(#c("SNR Threshold:", SNR_thresh),
                     c("Mass Range:", paste0('<i>m/z</i> ', mass_range[1], " - ", mass_range[2])),
                     c("Peak Alignment Method:", peak_alignment_method),
                     cluster_bin_size,
                     c("Background Peak Exclusion:", bg_exclusion),
                     c("Normalization Method:", normalization_method))

kable(settings_df,
      row.names = FALSE,
      align = "l",
      format = "html",
      escape = FALSE)%>%
  column_spec(1:2, width = "3in")%>% 
  kable_styling(full_width = FALSE, 
                font_size = 14)
```

```{r R data, include = FALSE}
#save(list = ls(), 
#     file=file.path(files_dir, paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"), "_", #proj_name,"_preproc.RData")))
```

<br>

#### **Session Info**

```{r}
sessionInfo()
```