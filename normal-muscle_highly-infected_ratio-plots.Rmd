---
title: "Normal Muscle vs Highly Infected Tissue Selected Ratios"
author: "<span style='font-size: 17px;'>`r Sys.info()[['user']]`</span><br><span style='font-size: 12px; color:#696969;'>Eberlin Lab, Department of Surgery<br>Baylor College of Medicine</span>"
date: "<span style='font-size: 15px; color: black;'>`r format(Sys.time(), '%B %d, %Y %H:%M')`</span>"
knit: (function(inputFile, encoding) { 
      proj_name <- tools::file_path_sans_ext(basename(inputFile));
      out_dir <- paste0(Sys.Date(), "_", proj_name);
      if(!file.exists(out_dir)) {   dir.create(out_dir) };
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), 
                        out_dir, 
                        paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"),"_", proj_name, ".html"))) 
                        })
output: 
  html_document:
    keep_md: yes
    toc: false
geometry: margin=0.5in
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style type="text/css">
.main-container {
max-width: 1600px;
margin-left: auto;
margin-right: auto;
}
</style>
```

```{css, echo=FALSE}
h1,h2, h3, h4, h5, p {
text-align: center;
font-size: 20px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE, cache = TRUE)
## cache set to TRUE because sometimes otherwise the files directory disappears for some users
```

```{r libraries, message = FALSE, warning = FALSE}
library(rmarkdown)
library(knitr)
library(kableExtra)
library(ggpubr)

library(tidyverse)
library(reshape2)
library(readxl)
library(rawrr)
library(sqldf)

library(stringr)
library(doParallel)
library(fcluster)
library(johnfuncs)
```

```{r user input}
## Full path to folder with sample files (excel or csv, or raw Thermo files)
sample_dir <- gsub("\\\\", "/", r"(C:\Users\Jacob\OneDrive - Baylor College of Medicine\Documents\Manoj\Microbial-Project\Data\Normal muscle vs Highly Infected)")

## Full path to feature list, otherwise NA
feature_file <- gsub("\\\\", "/", r"(C:\Users\Jacob\Box\Eberlin_Lab_BCM\People\MANOJ\Renamed_Gram_positive_Gram_negative_Isolates_May2025\molecular Identity with Chemical  Formula\Microbes_Identified_features_May_2025.xlsx)")

## Full path to background peak list, otherwise NA
background_file <- NA

## ---------------------------------------------------------------------------

## Scan numbers to import when using raw Thermo files
scans <- 1
#scans <- 50:500 ## number of scans to extract from each raw file

## Mass range to filter
mass_range <- c(100,1000)

## Peak Alignment Method: "clustering", "binning", or "featurelist"
peak_alignment_method <- "clustering"

## If peak alignment method is "clustering":
clust_h <- 0.05 ## Height at which to cut dendrogram to determine clusters

## If peak alignment method is "featurelist":
ppm_error <- 5 ## Mass error tolerance of sample peaks to match to feature peaks

## Normalization Method: "tic", "maxpeak", "median", "medianlog", or "none"
normalization_method <- "tic" 

## Select ratio peaks
## These values come from the gram classification Lasso ratio features
## From "Microbial-Project\outputs\ratio-lasso_gram_featurelist_2025-06-23\2025-06-23_16.12_ratio-lasso_gram_featurelist.html"
num_mz <- c(174.0884, 245.0433, 325.114, 325.114, 509.3484, 509.3484, 242.155, 253.2173, 270.1863, 662.4766, 714.5079)
den_mz <- c(688.4923, 746.4519, 702.5079, 730.5392, 728.5236, 749.5248, 735.5182, 325.114, 358.216, 765.53, 925.5677)
```

```{r create output directory, include = FALSE}
proj_name <- tools::file_path_sans_ext(basename(rstudioapi::getSourceEditorContext()$path))

out_dir <- file.path("outputs", paste0(proj_name, "_", Sys.Date()))

if(!file.exists(out_dir)) {   
  dir.create(out_dir, recursive = TRUE) 
  }

files_dir <- file.path(out_dir, paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"), "_", proj_name, "_files"))

if(!file.exists(files_dir)) {   
  dir.create(files_dir, recursive = TRUE) 
  }
```

```{r other settings}
## Signal-to-Noise Ratio Threshold
SNR_thresh <-  2

## Peak filter
p <- 0.10 ## A peak present in fewer than p*100% of samples is removed, default = 0.10 or 10%

## Randomization seed
seed <- 1234
```

```{r classes}
## read sub-directories for class names
classes <- gsub(file.path(sample_dir, "/"), "", list.dirs(sample_dir, recursive=FALSE), fixed=TRUE)
```

```{r file extension}
## Looking at all files since there is an extra directory level between classes and the files themselves
all_files <- list.files(sample_dir, recursive = TRUE, full.names = TRUE)
exts <- unique(tools::file_ext(all_files))

if (length(exts) == 0) {
  stop("No files found under sample_dir!")
} else if (length(exts) > 1) {
  warning("Multiple extensions detected: ", paste(exts, collapse = ", "))
}

sample_file_ext <- exts[1]
```

```{r file names}
## Added in extra level so that we keep species or skeletal/muscle information for possible future analysis
file_name_list <- lapply(classes, function(cl) {
  # find every species folder under class “cl”
  species_dirs <- list.dirs(
    path       = file.path(sample_dir, cl), 
    recursive  = FALSE, 
    full.names = TRUE
  )
  
  # list files in each species folder, matching .<ext> at the end
  files_per_species <- lapply(species_dirs, function(sp) {
    list.files(
      path       = sp,
      pattern    = paste0("\\.", sample_file_ext, "$"),  # regex for “.ext” at end
      full.names = TRUE
    )
  })
  
  # flatten into one vector and return
  unlist(files_per_species, use.names = FALSE)
})

# ensure consistent ordering
file_name_list <- lapply(file_name_list, sort)
```

```{r sample names}
sample_names_list <- lapply(file_name_list, function(x) tools::file_path_sans_ext(basename(x)))
names(sample_names_list) <- classes

sample_names <- unlist(sample_names_list)

sample_names_df <- purrr::map_df(sample_names_list, ~as.data.frame(.x), .id="id")
colnames(sample_names_df) <- c("class", "sample_name")
```

```{r csv data}
if (sample_file_ext == "csv") {
  fixed_objects <- list(mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_csv(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r excel data}
if (sample_file_ext == "xlsx") {
  fixed_objects <- list(mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_xlsx(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r raw Thermo data}
## If sample files are raw Thermo
if (sample_file_ext == "raw") {
  fixed_objects <- list(scans = scans, mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_raw_thermo(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r peak alignment clustering}
## If peak alignment method is clustering
if (peak_alignment_method == "clustering") {
  
  clust_int_method  <-  "sumints" ## Handling of multiple intensities aggregating to one cluster centroid: "sumints" or "maxint"
  
  all_mz <- spectra_list %>%
    flatten() %>%
    map(~ round(.x$m.z, 3)) %>%
    unlist() %>%
    sort()
  
  ## Cluster peaks into centroids
  tree <- fcluster(all_mz)
  clust_mz <- fcutree(all_mz, tree, h=clust_h)
  clustMZ <- sort(clust_mz$cen)
  
  ## Match cluster centroids to sample peaks
  clusterMatrixList <- lapply(spectra_list, function(x, y, z, w) 
    get_cluster_matrix(x, y, z, w), y=clustMZ, z = clust_h, w = clust_int_method)
  
  preprocList <- lapply(clusterMatrixList, function(x) as.matrix(get_data_matrix_clustering(x)))
  
  aligned_spectra <- do.call(rbind, preprocList)
  
  colnames(aligned_spectra) <- clustMZ
  rownames(aligned_spectra) <- sample_names
  
  ## FILTER #3: REMOVE RARE/UNCOMMON PEAKS PRESENT < 10% SAMPLES
  mz_count_filter <- colSums(aligned_spectra != 0) > as.integer(nrow(aligned_spectra)*p)
  aligned_spectra <- aligned_spectra[, mz_count_filter]
  
  filtered_mz <- clustMZ[mz_count_filter]
  
  centroid_min_max <- identify_clusters(clust_mz, all_mz)
  
  ## FILTER #4: REMOVE BACKGROUND PEAKS (IF BACKGROUND FILE PRESENT)
  if (!is.na(background_file)) {
    ## Read background file, check if it has a header
    if(is.character(read.csv(background_file, header = FALSE, nrows = 1)[1,1]) == TRUE) {
      bg_mz <- read.csv(background_file, header = TRUE)
    } else {
      bg_mz <- read.csv(background_file, header = FALSE)
    }
    
    colnames(bg_mz) <- "mz"
    
    # match bg_mz to cluster centroid
    bg_centroids <- sqldf("SELECT centroid_min_max.centroid, bg_mz.*
          FROM bg_mz,centroid_min_max
          WHERE bg_mz.mz BETWEEN centroid_min_max.min_mz AND centroid_min_max.max_mz")
    
    ## Remove peaks from aligned_spectra that are in bg_mz_centroid
    bg_ind <- which(filtered_mz %in% unique(bg_centroids$centroid))
    
    filtered_mz <- filtered_mz[-c(bg_ind)]
    aligned_spectra <- aligned_spectra[, -c(bg_ind)]
  }
}
```

```{r peak alignment binning}
if (peak_alignment_method == "binning") {
  ## Hard coded that m/z values are rounded to 2 decimal places and intensities of peaks that fall into the same bin are summed (by John Lin). 
  ## TBD about changing this - FEJ 2024-09-06
  
  all_mz <- spectra_list %>%
    flatten() %>%
    map(~ round(.x$m.z, 2)) %>% ## round to 2 decimal places
    unlist() %>%
    sort() 
  
  ## FILTER #3: REMOVE RARE/UNCOMMON PEAKS PRESENT < 10% SAMPLES
  mz_count <- table(all_mz)
  mz_count_filter <- mz_count > as.integer(length(sample_names)*p)
  filtered_mz <- as.numeric(names(mz_count)[mz_count_filter])
  
  ## Bin sample peaks
  preprocList <- lapply(spectra_list, function(x,z) get_data_matrix_binning(x,z), z=filtered_mz)
  
  aligned_spectra <- do.call(rbind, preprocList)
  
  colnames(aligned_spectra) <- filtered_mz
  rownames(aligned_spectra) <- sample_names
  
  ## FILTER #4: REMOVE BACKGROUND PEAKS (IF BACKGROUND FILE PRESENT)
  if (!is.na(background_file)) {
    ## Read background file, check if it has a header
    if(is.character(read.csv(background_file, header = FALSE, nrows = 1)[1,1]) == TRUE) {
      bg_mz <- round(read.csv(background_file, header = TRUE),2)
    } else {
      bg_mz <- round(read.csv(background_file, header = FALSE), 2)
    } ## round to 2 decimal places for binned values
    
    aligned_spectra <- aligned_spectra[, !(colnames(aligned_spectra) %in% bg_mz)]
    filtered_mz <- as.numeric(colnames(aligned_spectra))
  }
  
  centroid_min_max <- NA
}
```

```{r peak alignment feature list}
if (peak_alignment_method == "featurelist") {
  background_file <- NA
  
  ## Read file with feature peaks
  feature_df <- read.csv(feature_file, header = TRUE)
  feature_peaks <- feature_df[,1]
  
  ## Feature mz plus/minus instrument mass error, round to 3 decimal places
  mass_error <- (ppm_error * feature_peaks)/1e6
  
  feature_peaks <- data.frame(feature_mz = feature_peaks,
                              mass_error = mass_error,
                              mass_error_lower = round(feature_peaks - mass_error,3),
                              mass_error_upper = round(feature_peaks + mass_error,3))
  
  ## fixed objects for exporting to parallel computing
  fixed_objects <- list(feature_peaks = feature_peaks)
  
  feature_matched_spectra <- nested_feature_peak_alignment(spectra_list, fixed_objects)
  
  ## turn list of lists into dataframe
  feature_matched_spectra <- lapply(feature_matched_spectra, function(x) x %>%
                                      reduce(full_join,by = "feature_mz")) %>% 
    reduce(full_join,by = "feature_mz")
  
  ## sort by target_mz
  feature_matched_spectra <- feature_matched_spectra[order(feature_matched_spectra$feature_mz), ]
  
  filtered_mz <- feature_matched_spectra$feature_mz
  
  ## feature_mass column to rownames
  feature_matched_spectra <- feature_matched_spectra %>% 
    remove_rownames %>% 
    column_to_rownames(var = "feature_mz") %>% 
    as.data.frame()
  
  ## Add sample names as column names
  colnames(feature_matched_spectra) <- sample_names
  
  ## Replace NA with 0
  feature_matched_spectra <- replace(feature_matched_spectra, is.na(feature_matched_spectra), 0)
  
  ## Transpose so rows are samples and columns are masses
  aligned_spectra <- t(feature_matched_spectra)
  
  ## remove columns that are only zeros
  zero_col <- which(colSums(aligned_spectra==0) == nrow(aligned_spectra))
  if (length(zero_col) != 0) {
    filtered_mz <- filtered_mz[-c(zero_col)]
    aligned_spectra <- aligned_spectra[, -c(zero_col)]
  }
  
  centroid_min_max <- NA
}
```

```{r normalization}
xall <- normalize_pixel(aligned_spectra, normalization_method)
```

```{r yall}
## create yall object 
yall <- foreach(i = 1:length(file_name_list), .combine = c) %do% {
  rep(i, length(file_name_list[[i]])) }

## factorize yall
yall <- factor(yall,levels=c("1","2"),labels = classes)
```

``` {r select peaks of interest}
## Match peaks in xall to target peaks
col_mzs <- as.numeric(colnames(xall))
num_idx <- sapply(num_mz, function(m) which.min(abs(col_mzs - m)))
den_idx <- sapply(den_mz, function(m) which.min(abs(col_mzs - m)))
```

``` {r ratios}
## Build numerator and denominator matrices
numerator <- xall[, num_idx]
denominator <- xall[, den_idx]

## Manually check pairs
head(
  data.frame(
    sample = rownames(xall)[1:5],
    num    = numerator[1:5, 1],
    den    = denominator[1:5, 1],
    ratio  = log(numerator[1:5, 1] / denominator[1:5, 1])
  )
)

## Calculate ratios
ratio_df <- purrr::map_dfr(seq_len(ncol(numerator)), function(i) {
  tibble(
    class = yall,
    ratio = log(numerator[, i] / denominator[, i]),
    ratio_label = paste0("m/z ", num_mz[i], " / ", den_mz[i])
  )
})

## Make sure class is a factor
ratio_df <- ratio_df |>
  mutate(class = factor(class, levels = sort(unique(class))))

## Split into one df per ratio
ratio_list <- split(ratio_df, ratio_df$ratio_label)
```

``` {r plots}
## Plot each ratio separately and save
## Infinities are capped to just outside the min/max values and labelled accordingly
imap(ratio_list, function(df, ratio_nm) {

  # 1) Compute caps and flag infs
  fin <- df$ratio[is.finite(df$ratio)]
  top_cap <- max(fin, na.rm = TRUE) * 1.1
  bot_cap <- min(fin, na.rm = TRUE) * 0.9

  df2 <- df %>%
    mutate(
      plot_ratio = case_when(
        ratio ==  Inf ~ top_cap,
        ratio == -Inf ~ bot_cap,
        TRUE          ~ ratio
      ),
      inf_type = case_when(
        ratio ==  Inf ~ "posInf",
        ratio == -Inf ~ "negInf",
        TRUE          ~ "finite"
      )
    )

  # 2) Plot
  p <- ggplot(df2, aes(x = class, y = plot_ratio, shape = inf_type)) +
    # boxplot of only finite values
    geom_boxplot(
      data = filter(df2, inf_type=="finite"),
      aes(y = plot_ratio),
      width = 0.4, outlier.shape = NA, alpha = 0.2
    ) +
    # jitter all points, shape by inf_type
    geom_jitter(
      width = 0.15, size = 1.8, alpha = 0.7, colour = "black"
    ) +
    # shapes: circle for finite, up triangle for +Inf, down triangle for -Inf
    scale_shape_manual(
      values = c(
        finite = 16,
        posInf = 24,   # ▲ filled
        negInf = 25    # ▼ filled
      )
    ) +
    # y-axis from bot_cap to top_cap, labeling caps as “-Inf” and “Inf”
    scale_y_continuous(
      limits = c(bot_cap, top_cap),
      breaks = c(pretty(fin, 4), bot_cap, top_cap),
      labels = c(pretty(fin, 4), "-Inf", "Inf")
    ) +
    labs(
      title = ratio_nm,
      x     = "Tissue Type",
      y     = "Intensity Ratio"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      axis.text.x   = element_text(size = 11),
      plot.title    = element_text(hjust = 0.5),
      legend.position = "none"
    )

  # 3) Save
  safe_nm <- paste0("ratio_", gsub("[^0-9A-Za-z]+","_",ratio_nm),".png")
  ggsave(
    filename = file.path(files_dir, safe_nm),
    plot     = p,
    width    = 8, height = 10,
    dpi      = 300, bg = "white"
  )

  invisible(NULL)
})
```

<br>

#### **Preprocessing and Statistical Model Settings**

```{r chunk3, fig.align = "center"}
if (peak_alignment_method == "clustering") {
  cluster_bin_size <- c("Cluster Height:", clust_h)
} else if (peak_alignment_method == "binning") {
  cluster_bin_size <- c("Bin Size:", "0.01")
} else if (peak_alignment_method == "featurelist") {
  cluster_bin_size <- c("Peak Mass Error:", paste0(ppm_error, " ppm"))
}

if (is.null(background_file)) {
  bg_exclusion <- "no"
} else if (!is.null(background_file)) {
  bg_exclusion <- "yes"
}

settings_df <- rbind(#c("SNR Threshold:", SNR_thresh),
                     c("Mass Range:", paste0('<i>m/z</i> ', mass_range[1], " - ", mass_range[2])),
                     c("Peak Alignment Method:", peak_alignment_method),
                     cluster_bin_size,
                     c("Background Peak Exclusion:", bg_exclusion),
                     c("Normalization Method:", normalization_method))

kable(settings_df,
      row.names = FALSE,
      align = "l",
      format = "html",
      escape = FALSE)%>%
  column_spec(1:2, width = "3in")%>% 
  kable_styling(full_width = FALSE, 
                font_size = 14)
```

```{r R data, include = FALSE}
save(list = ls(), 
     file=file.path(out_dir, files_dir, paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"), "_", proj_name,"_preprocessed.RData")))
```

<br>

#### **Session Info**

```{r}
sessionInfo()
```